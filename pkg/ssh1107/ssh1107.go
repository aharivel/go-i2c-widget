package ssh1107

import (
	"fmt"
	"image"
	"image/color"
	"image/draw"
	"strings"

	"dev/pkg/i2c"
)

const (
	OLED_CMD                 = 0x80
	OLED_CMD_COL_ADDRESSING  = 0x21
	OLED_CMD_PAGE_ADDRESSING = 0x22
	OLED_CMD_CONTRAST        = 0x81
	OLED_CMD_START_COLUMN    = 0x00
	OLED_CMD_HIGH_COLUMN     = 0x10
	OLED_CMD_DISPLAY_OFF     = 0xAE
	OLED_CMD_DISPLAY_ON      = 0xAF
	OLED_DATA                = 0x40
	OLED_ADRESSING           = 0x21
	OLED_ADRESSING_START     = 0xB0
	OLED_ADRESSING_COL       = 0x21
	OLED_END                 = 0x10
	PIXSIZE                  = 8

	SH110X_BLACK   = 0 ///< Draw 'off' pixels
	SH110X_WHITE   = 1 ///< Draw 'on' pixels
	SH110X_INVERSE = 2 ///< Invert pixels

	SH110X_MEMORYMODE          = 0x20
	SH110X_COLUMNADDR          = 0x21
	SH110X_PAGEADDR            = 0x22
	SH110X_SETCONTRAST         = 0x81
	SH110X_CHARGEPUMP          = 0x8D
	SH110X_SEGREMAP            = 0xA0
	SH110X_DISPLAYALLON_RESUME = 0xA4
	SH110X_DISPLAYALLON        = 0xA5
	SH110X_NORMALDISPLAY       = 0xA6
	SH110X_INVERTDISPLAY       = 0xA7
	SH110X_SETMULTIPLEX        = 0xA8
	SH110X_DCDC                = 0xAD
	SH110X_DISPLAYOFF          = 0xAE
	SH110X_DISPLAYON           = 0xAF
	SH110X_SETPAGEADDR         = 0xB0
	SH110X_COMSCANINC          = 0xC0
	SH110X_COMSCANDEC          = 0xC8
	SH110X_SETDISPLAYOFFSET    = 0xD3
	SH110X_SETDISPLAYCLOCKDIV  = 0xD5
	SH110X_SETPRECHARGE        = 0xD9
	SH110X_SETCOMPINS          = 0xDA
	SH110X_SETVCOMDETECT       = 0xDB
	SH110X_SETDISPSTARTLINE    = 0xDC

	SH110X_SETLOWCOLUMN  = 0x00
	SH110X_SETHIGHCOLUMN = 0x10
	SH110X_SETSTARTLINE  = 0x40
)

var PROM = []byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf8, 0xfc,
	0xfc, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x83, 0xf9,
	0xf1, 0x87, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xfc,
	0xfc, 0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xe0, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0xe0, 0xf0, 0xf8, 0xf8, 0xfc, 0xfc, 0xfe,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x3f, 0x3f, 0x3f, 0x1f,
	0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xe1, 0xfc, 0xff, 0xff,
	0xff, 0xff, 0xf8, 0xc1, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f,
	0x1f, 0x3f, 0x3f, 0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xfe, 0xfc, 0xfc, 0xf8, 0xf0, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
	0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x3f,
	0x1f, 0x0f, 0x07, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x7f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0x7e, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x0f, 0x0f, 0x1f,
	0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0xfc, 0xfe, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xf3, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe1, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xfe, 0xfc, 0xf0, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x3f, 0x0f, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x7e, 0x7e, 0xfc,
	0xfc, 0xf8, 0xf8, 0xf0, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf8, 0xfc, 0xfe, 0xff, 0x7f, 0x1f, 0x0f, 0x0f, 0x0f,
	0x0f, 0x0f, 0x0f, 0x1f, 0x7f, 0xff, 0xfe, 0xfc, 0xf8, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xf0, 0xf0, 0xf8, 0xf8, 0xfc,
	0xfc, 0x7e, 0x3c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x3f, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf8, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x03, 0x07, 0x07, 0x0f, 0x0f, 0x1f, 0x3f, 0x3f, 0x7e, 0x7e, 0xfc, 0xfc, 0xf8,
	0xf0, 0xf0, 0xe0, 0xe0, 0xc0, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xc0, 0xe0, 0xe0, 0xf0, 0xf8,
	0xf8, 0xfc, 0xfc, 0x7e, 0x7e, 0x3f, 0x1f, 0x1f, 0x0f, 0x0f, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x0f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf0, 0x80, 0x00, 0x00,
	0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x03, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x07, 0x07, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7e, 0x7c, 0xfc, 0xf8,
	0xf8, 0xf0, 0xf0, 0xe0, 0xc0, 0xc0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x03, 0x03, 0x07, 0x07, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0xf8, 0xf0, 0xf0,
	0xf0, 0xf0, 0xf8, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x07, 0x07, 0x03, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf8,
	0xf8, 0xfc, 0x7e, 0x7e, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f, 0x07, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00,
	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x01, 0x03, 0x03, 0x07, 0x0f, 0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7e, 0xfc, 0xfc, 0xf8, 0xf8, 0xf0,
	0xf0, 0xe0, 0xf0, 0xf0, 0xf8, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x0f, 0x0f, 0x07, 0x07,
	0x07, 0x07, 0x0f, 0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf8, 0xf0, 0xf0, 0xe0, 0xf0,
	0xf0, 0xf8, 0xf8, 0xfc, 0x7e, 0x7e, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f, 0x07, 0x07, 0x03, 0x03, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xf8, 0xfc, 0x7e, 0x7e, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f,
	0x07, 0x07, 0x0f, 0x0f, 0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xf8, 0xf0, 0xe0, 0xe0,
	0xe0, 0xe0, 0xf0, 0xf8, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x1f, 0x0f, 0x0f, 0x07, 0x0f,
	0x0f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7e, 0xfc, 0xfc, 0xf8, 0xf8, 0xf0, 0xe0, 0xc0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
	0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xc0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
	0xc0, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc1, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
	0xc0, 0xc0, 0xe0, 0xe0, 0xf0, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1f, 0x1f, 0x0f, 0x0f,
	0x0f, 0x0f, 0x1f, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xe0, 0xe0, 0xc0, 0xc0,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xc0,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00,
	0x00, 0x00, 0x01, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xf0, 0xc0,
	0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
	0x3f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x1f, 0x1f, 0x1f,
	0x0f, 0x0f, 0x07, 0x07, 0x03, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x03, 0x07, 0x07, 0x0f, 0x0f,
	0x1f, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x3f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x00, 0x00,
	0xc0, 0xf0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x0f, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0f, 0x3f, 0xff, 0xff, 0x1f, 0x4f, 0x27, 0x33, 0xbd, 0xbe,
	0xbf, 0x9f, 0xdf, 0xdf, 0x9f, 0x0f, 0x0f, 0x0f, 0x0f, 0x07, 0x07, 0x07, 0x07, 0x03, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x0f, 0x0f, 0x9f, 0xdf, 0xdf, 0x9f, 0xbe,
	0xbc, 0xb9, 0x33, 0x27, 0x4f, 0x1f, 0xff, 0x7f, 0x3f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1f, 0x3f, 0x7f, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x7f, 0x3f, 0x0f, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
	0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xfc,
	0xf8, 0xf0, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xf0, 0xf0, 0xf8,
	0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x0f, 0x1f, 0x1f, 0x3f, 0x7f, 0x7f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0xf8,
	0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
	0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8,
	0xf8, 0xfc, 0xfc, 0xfc, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x7f, 0x3f, 0x3f, 0x1f, 0x0f, 0x0f, 0x07, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x0f, 0x0f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f,
	0x3f, 0x3f, 0x3f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x3f, 0x3f, 0x3f,
	0x3f, 0x1f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x07, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}

type Display interface {
	Initialize() error
	GetImage() draw.Image
	DisplayOn() (int, error)
	DisplayOff() (int, error)
	Display() error
	Display_old() error
	//	DisplayDirty(*screen) error
  GetBuffer() []byte
	Clear()
	Draw()
	DrawImg()
	DrawPix(int, int)
	DrawCircle(int, int, int)
	PrintAsASCIIArt()
	ClearImage(color.Color)
}

type SSH1107_128_128 struct {
	fd     *i2c.I2CDevice
	screen *screen
}

type screen struct {
	h        int        // Screen height in pixels
	w        int        // Screen width in pixels
	contrast int        // Current contrast level
	buffer   []byte     // Byte array representing the screen buffer
	Img      draw.Image // Image object used for rendering graphics

	// Dirty rectangle boundaries in pixel coordinates
	dirtyMinX int
	dirtyMinY int
	dirtyMaxX int
	dirtyMaxY int

	// Dirty rectangle boundaries in page coordinates
	dirtyMinPage int
	dirtyMaxPage int
}

// ///////////////////////////////////////////////////////
//
// # Declaration Functions
//
// //////////////////////////////////////////////////////
func NewScreen(h, w int) *screen {
	bufferSize := (w * h) / PIXSIZE
	return &screen{
		h:         h,
		w:         w,
		buffer:    make([]byte, bufferSize),
		Img:       image.NewRGBA((image.Rect(0, 0, int(w), int(h)))),
		dirtyMinX: 0,
		dirtyMinY: 0,
		dirtyMaxX: 128,
		dirtyMaxY: 128,
	}
}

func NewDisplay(fd *i2c.I2CDevice, screen *screen) (Display, error) {
	fmt.Println("Init display", screen.w, screen.h)
	switch {
	case screen.w == 128 && screen.h == 128:
		return newSSH1107_128_128(fd, screen), nil
	default:
		return nil, fmt.Errorf("unsupported display dimensions: %dx%d", screen.w, screen.h)
	}
}

/////////////////////////////////////////////////////////
//
// # Interface Functions
//
////////////////////////////////////////////////////////

func (d *SSH1107_128_128) Initialize() error {
	fmt.Println("Initialize screen")

	data := []byte{
		SH110X_DISPLAYOFF,               // 0xAE
		SH110X_SETDISPLAYCLOCKDIV, 0x51, // 0xd5, 0x51,
		SH110X_MEMORYMODE,        // 0x20
		SH110X_SETCONTRAST, 0x4F, // 0x81, 0x4F
		SH110X_DCDC, 0x8A, // 0xAD, 0x8A
		SH110X_SEGREMAP,              // 0xA0
		SH110X_COMSCANINC,            // 0xC0
		SH110X_SETDISPSTARTLINE, 0x0, // 0xDC 0x00
		SH110X_SETDISPLAYOFFSET, 0x60, // 0xd3, 0x60,
		SH110X_SETPRECHARGE, 0x22, // 0xd9, 0x22,
		SH110X_SETVCOMDETECT, 0x35, // 0xdb, 0x35,
		SH110X_SETMULTIPLEX, 0x3F, // 0xa8, 0x3f,
		SH110X_SETPAGEADDR,      // 0xb0
		SH110X_SETCOMPINS, 0x12, // 0xda, 0x12,
		SH110X_DISPLAYALLON_RESUME, // 0xa4
		SH110X_NORMALDISPLAY,       // 0xa6
		SH110X_SETDISPLAYOFFSET, 0x00, SH110X_SETMULTIPLEX, 0x7F,
	}

	return sendCommands(*d.fd, data...)
}

func (d *SSH1107_128_128) GetImage() draw.Image {
	return d.screen.Img
}

func (d *SSH1107_128_128) DrawImg() {
	copy(d.screen.buffer, PROM)
	return
}

func (d *SSH1107_128_128) GetBuffer() []byte{
	return d.screen.buffer
}

// Turn on OLED display
func (d *SSH1107_128_128) DisplayOn() (int, error) {
	return writeCommand(*d.fd, OLED_CMD_DISPLAY_ON)
}

// Turn off OLED display
func (d *SSH1107_128_128) DisplayOff() (int, error) {
	return writeCommand(*d.fd, OLED_CMD_DISPLAY_OFF)
}

// Display buffer to the screen for SH1107
func (d *SSH1107_128_128) Display_old() error {
	// Start by setting the column address
	for page := 0; page < d.screen.h/8; page++ {
		// Set the page address
		_, err := writeCommand(*d.fd, byte(0xB0|page)) // SH1107 uses 0xB0 to 0xB7 for page addressing
		if err != nil {
			return err
		}

		// Set the lower column start address
		_, err = writeCommand(*d.fd, 0x00) // Lower nibble of the column address
		if err != nil {
			return err
		}

		// Set the higher column start address
		_, err = writeCommand(*d.fd, 0x10) // Higher nibble of the column address
		if err != nil {
			return err
		}

		// Transfer one page of data (d.screen.buffer is split into pages)
		start := page * d.screen.w
		end := start + d.screen.w
		if end > len(d.screen.buffer) {
			end = len(d.screen.buffer)
		}

		data := d.screen.buffer[start:end]
		_, err = writeData(*d.fd, data)
		if err != nil {
			return err
		}
	}

	return nil
}

// Display updates the display buffer to the screen for SH1107
func (d *SSH1107_128_128) Display() error {
	buffer := d.screen.buffer
	pages := (d.screen.h + 7) / 8 // Total number of pages (rows of 8 pixels)
	bytesPerPage := d.screen.w    // Width in bytes per page

	// Default to update the entire display
	windowX1 := 0
	windowY1 := 0
	windowX2 := d.screen.w - 1
	windowY2 := d.screen.h - 1

	// Optional: If you track dirty regions, update windowX1, windowY1, etc., here
	// (For now, assume we are updating the whole screen.)

	firstPage := windowY1 / 8
	lastPage := min(pages, (windowY2+7)/8)

	pageStart := min(bytesPerPage, windowX1)
	pageEnd := max(0, windowX2)

	for page := firstPage; page < lastPage; page++ {
		// Set the page address
		if _, err := writeCommand(*d.fd, byte(0xB0|page)); err != nil {
			return err
		}

		// Set the higher and lower column start addresses
		columnStart := pageStart // + d.pageStartOffset // Offset adjustment if required
		if _, err := writeCommand(*d.fd, byte(0x10|(columnStart>>4))); err != nil {
			return err
		}
		if _, err := writeCommand(*d.fd, byte(columnStart&0x0F)); err != nil {
			return err
		}

		// Calculate bytes to write for this page
		bytesRemaining := bytesPerPage - pageStart
		bytesRemaining -= (bytesPerPage - 1) - pageEnd

		// Pointer to the start of the buffer for this page
		ptr := buffer[page*bytesPerPage+pageStart : page*bytesPerPage+pageStart+bytesRemaining]

		// Write the buffer to the display
		if _, err := writeData(*d.fd, ptr); err != nil {
			return err
		}
	}

	return nil
}

/*
func (d *SSH1107_128_128) DisplayDirty(d.screen *screen) error {
	// Calculate dirty window in terms of pages and columns
	firstPage := d.screen.dirtyY1 / 8
	lastPage := (d.screen.dirtyY2 + 7) / 8
	startColumn := d.screen.dirtyX1
	endColumn := d.screen.dirtyX2

	for page := firstPage; page <= lastPage; page++ {
		// Set the page address
		if _, err := writeCommand(*d.fd, byte(0xB0|page)); err != nil {
			return err
		}

		// Set the column start and end addresses
		if _, err := writeCommand(*d.fd, byte(0x10|(startColumn>>4))); err != nil {
			qeturn err
		}
		if _, err := writeCommand(*d.fd, byte(startColumn&0x0F)); err != nil {
			return err
		}

		// Write the dirty portion of this page
		startIndex := page*d.screen.w + startColumn
		endIndex := page*d.screen.w + endColumn + 1
		if _, err := writeData(*d.fd, d.screen.buffer[startIndex:endIndex]); err != nil {
			return err
		}
	}

	// Reset dirty window after update
	d.screen.initializeDirtyWindow()

	return nil
}
*/
// Clear the OLED screen
func (d *SSH1107_128_128) Clear() {
	size := d.screen.w * d.screen.h / PIXSIZE
	d.screen.buffer = make([]byte, size)
}

func (d *SSH1107_128_128) ClearImage(col color.Color) {
	// Fill the entire image with the specified color
	draw.Draw(d.screen.Img, d.screen.Img.Bounds(), &image.Uniform{C: col}, image.Point{}, draw.Src)
}

// Set pixel
func (d *SSH1107_128_128) DrawPix(x int, y int) {
	if x >= 0 && x < d.screen.Img.Bounds().Dx() && y >= 0 && y < d.screen.Img.Bounds().Dy() {
		d.screen.Img.Set(x, y, color.White)
	}
}

func (d *SSH1107_128_128) DrawCircle(cx, cy, radius int) {
	x := radius
	y := 0
	decisionOver2 := 1 - x // Decision variable to determine pixel positions

	for x >= y {
		// Draw the 8 octants of the circle
		d.screen.Img.Set(cx+x, cy+y, color.White)
		d.screen.Img.Set(cx-x, cy+y, color.White)
		d.screen.Img.Set(cx+x, cy-y, color.White)
		d.screen.Img.Set(cx-x, cy-y, color.White)
		d.screen.Img.Set(cx+y, cy+x, color.White)
		d.screen.Img.Set(cx-y, cy+x, color.White)
		d.screen.Img.Set(cx+y, cy-x, color.White)
		d.screen.Img.Set(cx-y, cy-x, color.White)

		y++
		if decisionOver2 <= 0 {
			decisionOver2 += 2*y + 1
		} else {
			x--
			decisionOver2 += 2*(y-x) + 1
		}
	}
}

func (d *SSH1107_128_128) PrintAsASCIIArt() {
	bounds := d.screen.Img.Bounds()
	width := bounds.Max.X
	height := bounds.Max.Y

	// Print top border
	fmt.Println("   " + strings.Repeat("-", width+2))

	for y := 0; y < height; y++ {
		// Print left border
		fmt.Print("  |")
		for x := 0; x < width; x++ {
			col := color.GrayModel.Convert(d.screen.Img.At(x, y)).(color.Gray)
			if col.Y > 127 {
				fmt.Print("*") // Pixel is "on"
			} else {
				fmt.Print(" ") // Pixel is "off"
			}
		}
		// Print right border
		fmt.Println("|")
	}

	// Print bottom border
	fmt.Println("   " + strings.Repeat("-", width+2))
}

/*
	func (d *SSH1107_128_128) convertImageToOLEDData(d.screen *screen) ([]byte, int, int, int, int, error) {
		bounds := d.screen.Img.Bounds()
		if bounds.Max.X != d.screen.w || d.screen.h != bounds.Max.Y {
			panic(fmt.Sprintf("Error: Size of image is not %dx%d pixels.", d.screen.w, d.screen.h))
		}

		size := d.screen.w * d.screen.h / PIXSIZE
		data := make([]byte, size)

		// Initialize dirty window variables
		minX, maxX := d.screen.w, 0
		minPage, maxPage := d.screen.h/8, 0

		for page := 0; page < d.screen.h/8; page++ {
			for x := 0; x < d.screen.w; x++ {
				bits := uint8(0)
				for bit := 0; bit < 8; bit++ {
					y := page*8 + 7 - bit
					if y < d.screen.h {
						col := color.GrayModel.Convert(d.screen.Img.At(x, y)).(color.Gray)
						if col.Y > 127 {
							bits = (bits << 1) | 1
						} else {
							bits = bits << 1
						}
					}
				}
				index := page*d.screen.w + x
						if data[index] != d.screen.buffer[index] { // Check if pixel data has changed
							data[index] = bits

							// Update dirty window bounds
							if x < minX {
								minX = x
							}
							if x > maxX {
								maxX = x
							}
							if page < minPage {
								minPage = page
							}
							if page > maxPage {
								maxPage = page
							}
						}
			}
		}

		// Return the updated data and dirty window bounds
		return data, minX, maxX, minPage, maxPage, nil
	}

	func (d *SSH1107_128_128) Draw(d.screen *screen) {
		data, minX, maxX, minPage, maxPage, _ := d.convertImageToOLEDData(d.screen)

		d.screen.buffer = data
		d.screen.dirtyMinX = minX
		d.screen.dirtyMaxX = maxX
		d.screen.dirtyMinPage = minPage
		d.screen.dirtyMaxPage = maxPage
	}
*/
func (d *SSH1107_128_128) convertImageToOLEDData() ([]byte, error) {
	size := d.screen.w * d.screen.h / PIXSIZE
	data := make([]byte, size)
	for page := 0; page < d.screen.h/8; page++ {
		for x := 0; x < d.screen.w; x++ {
			bits := uint8(0)
			for bit := 0; bit < 8; bit++ {
				y := page*8 + 7 - bit
				if y < d.screen.h {
					col := color.GrayModel.Convert(d.screen.Img.At(x, y)).(color.Gray)
					if col.Y > 127 {
						bits = (bits << 1) | 1
					} else {
						bits = bits << 1
					}
				}
			}
			index := page*d.screen.w + x
			data[index] = byte(bits)
		}
	}
	return data, nil
}

func (d *SSH1107_128_128) Draw() {
	d.screen.buffer, _ = d.convertImageToOLEDData()
}

// //////////////////////////////////////////////////////
//
// # Private Functions
//
// //////////////////////////////////////////////////////
func newSSH1107_128_128(fd *i2c.I2CDevice, screen *screen) *SSH1107_128_128 {
	return &SSH1107_128_128{
		fd:     fd,
		screen: screen,
	}
}

// Send data to OLED
func writeData(fd i2c.I2CDevice, data []byte) (int, error) {
	res := 0
	for _, value := range data {
		if _, err := fd.Write([]byte{OLED_DATA, value}); err != nil {
			return res, err
		}
		res++
	}
	return res, nil
}

// writeCommand sends a single command byte to the SSH1107 device
func writeCommand(fd i2c.I2CDevice, cmd byte) (int, error) {
	return fd.Write([]byte{OLED_CMD, cmd})
}

// sendCommands sends a sequence of command bytes to the SSH1107 device.
func sendCommands(fd i2c.I2CDevice, commands ...byte) error {
	for _, cmd := range commands {
		if _, err := writeCommand(fd, cmd); err != nil {
			return err
		}
	}
	return nil
}

/*
	func (s *screen) initializeDirtyWindow() {
		s.dirtyX1 = s.w
		s.dirtyY1 = s.h
		s.dirtyX2 = -1
		s.dirtyY2 = -1
	}

func (s *screen) UpdateDirtyPages() {
	s.dirtyMinPage = s.dirtyMinY / 8
	s.dirtyMaxPage = (s.dirtyMaxY + 7) / 8 // Add 7 to round up to the nearest page
}
*/
